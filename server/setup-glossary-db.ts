import { db } from './db';
import { sql } from 'drizzle-orm';

/**
 * Setup glossary database tables and initialize the auto-update system
 */
export async function setupGlossaryDatabase(): Promise<void> {
  try {
    console.log('üîß Setting up glossary database tables...');

    // Create glossary_entries table
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS glossary_entries (
          id SERIAL PRIMARY KEY,
          question_id INTEGER REFERENCES questions(id) ON DELETE CASCADE,
          term VARCHAR(255) NOT NULL,
          category VARCHAR(100) DEFAULT 'General',
          confidence_score DECIMAL(3,2) DEFAULT 0.00,
          auto_generated BOOLEAN DEFAULT false,
          is_active BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          UNIQUE(question_id)
      )
    `);

    // Create glossary_update_log table
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS glossary_update_log (
          id SERIAL PRIMARY KEY,
          last_checked TIMESTAMP NOT NULL,
          terms_processed INTEGER DEFAULT 0,
          terms_added INTEGER DEFAULT 0,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create indexes for performance
    await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_glossary_entries_term ON glossary_entries(term)`);
    await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_glossary_entries_category ON glossary_entries(category)`);
    await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_glossary_entries_active ON glossary_entries(is_active)`);
    await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_glossary_entries_auto_generated ON glossary_entries(auto_generated)`);
    await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_glossary_update_log_last_checked ON glossary_update_log(last_checked)`);

    // Insert initial log entry if none exists
    await db.execute(sql`
      INSERT INTO glossary_update_log (last_checked, terms_processed, terms_added)
      SELECT CURRENT_TIMESTAMP - INTERVAL '1 day', 0, 0
      WHERE NOT EXISTS (SELECT 1 FROM glossary_update_log)
    `);

    console.log('‚úÖ Glossary database tables setup completed');

  } catch (error) {
    console.error('‚ùå Error setting up glossary database:', error);
    throw error;
  }
}

/**
 * Get glossary statistics
 */
export async function getGlossaryStats(): Promise<{
  totalTerms: number;
  autoGenerated: number;
  recentlyAdded: number;
  lastUpdate: Date | null;
}> {
  try {
    const statsResult = await db.execute(sql`
      SELECT 
        COUNT(*) as total_terms,
        COUNT(CASE WHEN auto_generated = true THEN 1 END) as auto_generated,
        COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as recently_added
      FROM glossary_entries 
      WHERE is_active = true
    `);

    const lastUpdateResult = await db.execute(sql`
      SELECT last_checked 
      FROM glossary_update_log 
      ORDER BY last_checked DESC 
      LIMIT 1
    `);

    const stats = statsResult.rows[0];
    const lastUpdate = lastUpdateResult.rows[0]?.last_checked || null;

    return {
      totalTerms: parseInt(stats.total_terms) || 0,
      autoGenerated: parseInt(stats.auto_generated) || 0,
      recentlyAdded: parseInt(stats.recently_added) || 0,
      lastUpdate: lastUpdate ? new Date(lastUpdate) : null
    };

  } catch (error) {
    console.error('‚ùå Error getting glossary stats:', error);
    return {
      totalTerms: 0,
      autoGenerated: 0,
      recentlyAdded: 0,
      lastUpdate: null
    };
  }
}